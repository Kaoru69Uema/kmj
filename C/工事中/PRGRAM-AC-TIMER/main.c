// プログラマブル　AC　タイマー
// 上間つよし＠沖縄県西原町＠久米島出身
// 令和4年2022年10月3日
// (2014年1月16日午後2時44分 上間つよし)

// ATmega328p 1MHz 工場出荷時

/////////////////////////////////////////////////////////
// NO.   Timer.                                        //
//  ---   ---   ---   ---                              //
// |   | |   | |   | |   |  * Stert  @                 //
//  ---   ---   ---   ---   * Stop   @                 //
// |   | |   | |   | |   |                             //
//  --- . --- . --- . --- . @ Set(W-click)             //
//                                                     //
// * min  * sec  * 0.1sec   @ Sel                      //
// @ Enc  @ INC  @ DEC      @ END                      //
//                                                     //
//  *    *    *    *    *    *    *    *    *    *     //
//  @    @    @    @    @    @    @    @    @    @     //
//-----------------------------------------------------//
//                                                     //
// (||) (||) (||) (||) (||) (||) (||) (||) (||) (||)   //
//                                                     //
/////////////////////////////////////////////////////////
//
//
//
//
//
// Switch    15個　　ADC0
// Encoder    1個    ADC1
// LED+SSR   13個    PORTB(8), PORTD(5)
// Huse(1A)   8個
// Case
//
//

//      0[v]------+--------+---------+---------+---------+---------+---------+---------+
//                |        |         |         |         |         |         |         |
//               SW16     SW15      SW14      SW13      SW12      SW11      SW10      SW9
//                |        |         |         |         |         |         |         |
//                +--R12K--+--R7.5K--+--R4.7K--+--R3.3K--+--R2.4K--+--R1.8K--+--R1.5K--+
//                                                                                     |
//      0[v]---+--------+--------+--------+--------+--------+--------+-------+         |
//             |        |        |        |        |        |        |       |         |
//            SW1      SW2      SW3      SW4      SW5      SW6      SW7     SW8        |
//             |        |        |        |        |        |        |       |         |
//   +--R6.8K--+--R330--+--R470--+--R510--+--R680--+--R750--+--R820--+--R1K--+--R1.2K--+
//   |         |
//   |  +------+                                  5[V]
//   |  |                                         |
//   +--|-----------------------------------------+
//      |                                         |
//      |                                         |
//      |                          _____          |
//      |               〜RESET---|.    |---VCC---+
//   +--|---R330--＜LED|----PB3---|tiny |---PB2(SCK)----|LED＞----R330----+
//   |  +-------------------PB4---| 13A |---PB1(MIS0)---|LED＞----R330----+
//   +----------------------GND---|_____|---PB0(MOSI)---|LED＞----R330----+
//   |                                                                    |
//   |                                                                    |
//   0[V]                                                                 0[V]
//

// 説明： アナログADC入力(ADC2:PB4)１本の入力値で、１６個のスイッチを判別して、LEDに出力

// ADC2:PB4（値  6未満）：SW番号0x00：SW1 ：LED(０００１)
// ADC2:PB4（値 20未満）：SW番号0x01：SW2 ：LED(００１０)
// ADC2:PB4（値 35未満）：SW番号0x02：SW3 ：LED(００１１)
// ADC2:PB4（値 50未満）：SW番号0x03：SW4 ：LED(０１００)
// ADC2:PB4（値 66未満）：SW番号0x04：SW5 ：LED(０１０１)
// ADC2:PB4（値 81未満）：SW番号0x05：SW6 ：LED(０１１０)
// ADC2:PB4（値 95未満）：SW番号0x06：SW7 ：LED(０１１１)
// ADC2:PB4（値110未満）：SW番号0x07：SW8 ：LED(１０００)
// ADC2:PB4（値125未満）：SW番号0x08：SW9 ：LED(１００１)
// ADC2:PB4（値139未満）：SW番号0x09：SW10：LED(１０１０)
// ADC2:PB4（値153未満）：SW番号0x0a：SW11：LED(１０１１)
// ADC2:PB4（値168未満）：SW番号0x0b：SW12：LED(１１００)
// ADC2:PB4（値182未満）：SW番号0x0c：SW13：LED(１１０１)
// ADC2:PB4（値193未満）：SW番号0x0d：SW14：LED(１１１０)
// ADC2:PB4（値211未満）：SW番号0x0e：SW15：LED(１１１１)
// ADC2:PB4（値231未満）：SW番号0x0f：SW16：LED(００００)<->LED(１１１１)：：blink
// ADC2:PB4（値231以上）：SW番号0xff：    ：LED(００００)

#include <avr/io.h>
#include <avr/interrupt.h>

volatile unsigned char t_flag=0;        // 1ms時間調整フラグ

unsigned int  c1000;           // 1000ms カウンタ

unsigned char zabswu = 0xff;   // 立ち上がりフラグ未押下
unsigned char zabswd = 0xff;   // 立ち下がりフラグ未押下
unsigned char zabswk = 0xff;   // 確定値未押下
unsigned char zabswz = 0xff;   // 前回未押下
unsigned char zacsw  = 00;     // ２０回連続カウンタ初期化
unsigned char zabswn = 0xff;   // 今回ＳＷ番号

unsigned char tmp1, tmp2;      // ハードの失敗をソフトで調整する　一時変数


//------------------------------------
// アナログＳＷ判定定数定義
//------------------------------------
const unsigned char q_asw[16] = {   6, 20, 35, 50, 66, 81, 95,110,
	125,139,153,168,182,197,211,231,};



ISR(TIMER0_COMPA_vect);
void asw( void );

int main(void)
{
	TCCR0A = (1<<WGM01);        // CTC Timer
	TCCR0B = (1<<CS01);         // ck/8
	OCR0A  = 1000000/8/1000-1;  // ﾀｲﾏ/ｶｳﾝﾀ 比較Aﾚｼﾞｽﾀ  1000Hzで割り込み
	TIMSK0 = 1<<OCIE0A;         // ﾀｲﾏ/ｶｳﾝﾀ割り込みﾏｽｸ ﾚｼﾞｽ
	TCNT0 = 0;                  // タイマ／カウンタ
	ADMUX = (1<<REFS0)|(0b0101<<MUX0)|(1<<ADLAR); // AVCC, ADC5, 左揃え
	ADCSRA = (1<<ADEN)|(1<<ADSC)|(1<<ADATE);  // ADC起動, 変換開始, 変換自動起動許可, CK/2, 連続変換動作

	sei();

	while(1)
	{
		PORTB=0;  // 一旦消灯

		tmp1 = zabswk;

		if( tmp1>=0 && tmp1<=14 ) {
			PORTB = tmp1+1;
		} else if( tmp1 == 15 ) {
			if( ++c1000==1000 ) c1000=0;
			if( c1000>=500 ) {
				PORTB = 0b00001111;
			} else {
				PORTB = 0b00000000;
			}
		} else if( tmp1 == 0xff) {            // SW 押されていない
			PORTB = 0b00000000;

		}

		asw();                  // アナログスイッチ判定

		while( t_flag==0 ) ;    // 以下２行
		t_flag=0;               // で1msのタイミング調整


	}
}


/*--------------------------------------------------*/
/*        アナログスイッチ判定                      */
/*--------------------------------------------------*/
void asw( void )
{
	unsigned char i;                        // ワークカウンタ

	zabswu = 0xff;                          // 立ち上がりフラグクリア
	zabswd = 0xff;                          // 立ち下がりフラグクリア

	// ***** ＳＷ番号検索 *****
	for( i = 0; i < sizeof( q_asw ); i++ ) { // A/D値検索
		if( ADCH < q_asw[i] )  break;  // A/D＜q_asw[i] ならＳＷ番号確定
	}
	if( i == sizeof( q_asw ) ) i = 0xff;    // 範囲外（未押下）なら0xffに補正
	zabswn = i;                             // 今回ＳＷ番号＝00〜0fh,0ffH


	// ***** 立ち上がり／立ち下がり処理 *****
	if( zabswn == zabswz ) {                        // *** 今回＝前回 の場合 ***
		if( ++zacsw >= 21 ) {           // 連続カウンタ　＋１, ２１回以上？
			zacsw = 20;             // 連続２１回以上は２０回に補正
			return;
		}
		if( zacsw == 20 ) {             // １９→２０回の場合
			if( zabswk == 0xff ) {  // 確定値が未押下なら
				zabswd = zabswn;// 立ち下がりフラグセット
			} else {
				zabswu = zabswk;// 立ち上がりフラグセット
			}
			zabswk = zabswn;        // 確定値セット
		}
		return;
	} else {                                // *** 今回≠前回 の場合 ***
						// 確定値＝未押下or確定値≠今回なら
		if( ( zabswk == 0xff ) || ( zabswk != zabswn ) )
			zacsw = 1;              // 連続押下カウンタ初期化
	}
	zabswz = zabswn;                        // 前回←今回
}


/*--------------------------------------------------*/
/*        タイマー割り込み０CTC動作                 */
/*--------------------------------------------------*/
ISR(TIMER0_COMPA_vect)
{
	t_flag=1;
}




